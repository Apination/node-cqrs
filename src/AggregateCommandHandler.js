'use strict';

const Observer = require('./Observer');
const ConcurrencyError = require('./errors/ConcurrencyError');
const isClass = require('./di/isClass');
const coWrap = require('./utils/coWrap');

const COMMIT_RETRIES_LIMIT = 5;
const COMMAND_TO_EVENT_CONTEXT_FIELDS = [
	'sagaId',
	'sagaVersion',
	'context',
	'auth'
];

const _eventStore = Symbol('eventStore');
const _aggregateFactory = Symbol('aggregateTypeOrFactory');
const _handles = Symbol('handles');

module.exports = class AggregateCommandHandler extends Observer {

	/**
	 * Creates an instance of AggregateCommandHandler.
	 *
	 * @param {{ eventStore: object, aggregateType: class, handles: string[] }}
	 */
	constructor({ eventStore, aggregateType, handles }) {
		if (!eventStore) throw new TypeError('eventStore argument required');
		if (!aggregateType) throw new TypeError('aggregateType argument required');
		super();

		coWrap(this);

		Object.defineProperties(this, {
			[_eventStore]: {
				value: eventStore
			},
			[_aggregateFactory]: {
				value: isClass(aggregateType) ?
					params => new aggregateType(params) : // eslint-disable-line new-cap
					aggregateType
			},
			[_handles]: {
				value: handles || aggregateType.handles
			}
		});
	}

	/**
	 * Subscribe to all command types handled by aggregateType
	 *
	 * @param {EventEmitter} commandBus
	 * @returns {Promise<any[]>} - whatever EventEmitter.on returns for each messageType
	 */
	subscribe(commandBus) {
		return super.subscribe(commandBus, this[_handles], this.execute);
	}

	/**
	 * Restore aggregate from event store events
	 *
	 * @param {string} id
	 * @returns {Aggregate}
	 */
	* _restoreAggregate(id) {
		if (!id) throw new TypeError('id argument required');

		const events = yield this[_eventStore].getAggregateEvents(id);
		const aggregate = this[_aggregateFactory]({ id, events });
		this.info(`aggregate ${aggregate.id} created`);

		return aggregate;
	}

	/**
	 * Create new aggregate with new Id generated by event store
	 *
	 * @returns {Aggregate}
	 */
	* _createAggregate() {
		const id = yield this[_eventStore].getNewId();
		const aggregate = this[_aggregateFactory]({ id });
		this.info(`aggregate ${aggregate.id} (v${aggregate.version}) restored from event store`);

		return aggregate;
	}

	/**
	 * Pass a command to corresponding aggregate
	 *
	 * @param {{type: string}} cmd - command to execute
	 * @return {Promise<object[]>} events
	 */
	* execute(cmd, options) {
		if (!cmd) throw new TypeError('cmd argument required');
		if (!cmd.type) throw new TypeError('cmd.type argument required');

		const aggregate = yield cmd.aggregateId ?
			this._restoreAggregate(cmd.aggregateId) :
			this._createAggregate();

		aggregate.handle(cmd);

		const events = aggregate.changes;
		if (!events || !events.length)
			return [];

		const fieldsToCopy = COMMAND_TO_EVENT_CONTEXT_FIELDS.filter(fieldName => fieldName in cmd);
		events.forEach(event => {
			fieldsToCopy.forEach(fieldName => {
				if (!(fieldName in event)) {
					event[fieldName] = cmd[fieldName];
				}
			});
		});

		try {
			this[_eventStore].commit(events);
		}
		catch (err) {
			if (err.name === ConcurrencyError.name) {
				const currentIteration = (options && options.iteration) || 0;
				if (currentIteration < COMMIT_RETRIES_LIMIT) {
					return this.execute(cmd, { iteration: currentIteration + 1 });
				}
			}
			throw err;
		}

		this.info(`command '${cmd.type}' processed, ${events.length === 1 ? '1 event' : `${events.lengts} events`} produced`);

		return events;
	}
};
